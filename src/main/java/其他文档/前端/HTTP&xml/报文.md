# 报文详解

## 一、什么是报文 

报文，是网络中交换和传输的数据单元，即站点一次性要发送的数据块。报文包含了将要发 送的完整的数据信息，其长短很不一致，长度不限且可变。 HTTP 报文是由一行一行简单的字符串组成的。HTTP 报文都是纯文本，不是二进制代码， 所以人们可以很方便地对其进行读写。如果说 HTTP 是因特网的信使，那么 HTTP 报文就 是它用来搬东西的包裹了。

## 二、报文的流动 

报文会流入源端服务器，工作完成之后，会流回用户的 Agent 代理。 HTTP 报文会像河水一样流动，不管是请求报文还是响应报文，所有报文都会向下游流动。 所有报文的发送者都在接受者的上游。

## 三、常见的三种报文格式

以下简单介绍了常见的三种报文格式：8583、XML、HTTP;

### 1、ISO8583

字段数据类型：字母、数字、特殊字符、年月日等时间、二进制数据；
8583报文为了解决网络带宽的问题，引入包头，即在报文前面加上包头，我们用16个字节，即128个bit（一个字节等于8bit）来表示128个字段中的某个字段是否存在。每个bit在计算机的二进制里面不是1就是0，如果是1就表示对应的字段在本次报文中存在，如果是0就是不存在。如果别人接收到了ISO8583报文，可以先根据最前面的报文头，就知道紧接着报文头后面的报文有哪些字段，没有哪些字段了。比如，我要发送5个字段，分别属于128个字段中的第2、3、6、8、9字段，我就可以将128bit的报文头填成011001011000000000………..，一共128个bit，后面就全是0了。注意其中第2、3、6、8、9位为1，其他都为0。
     有了这个128bit的报文头，我们就可以只发送需要的5个字段了。怎样组织报文？先放上这128bit，即16个字节的头，然后在头后面放2、3、6、8、9字段，这些字段紧挨在一起，3和6之间也不需要填上4、5这两个字段了。接收方收到这个报文，它会根据128bit的报文头来解包，它自然知道把第3个字段取出后，就直接在第3字段的后面取第6个字段，每个字段的长度在ISO8583里面都定义好了，很轻松就把数据包解出来了。

​     我们把这16个字节称为bit map，即位图，用来表示某个位是否存在。考虑到很多时候报文不需要128个字段这么多，其一半64个字段都不一定能够用完。那我可以将报文头由128bit减到64bit，只有在需要的时候才把剩下的64bit放到报文里面，这样报文长度又少了8个字节;

​     我们把ISO8583的128个字段中最常见的都放到前64个字段中，那我们可以将处理缩小一倍。这样我一般发送报文时只需发送64bit，即一个字节的报文头，再加上需要的几个字段就可以了。如果有些报文用到64到128之间的字段呢？这个也好办，我把64bit报文头的第一位bit用来代表特殊含义，如果该bit为1，则表示64bit后面跟了剩下的64bit报文头；如果第一位bit为0，则表示64bit后面没有跟剩下的64bit报文头，直接是128个字段中的报文了。那们，接收方会判断一下报头的第一个bit是1还是0，从而知道报文头是64bit还是128bit了，就可以做相应处理。因为报文头第二个64bit属于有时候有，所以我们叫它Extended bit map扩展位图，相应的报文头最开始的64bit我们叫它Primary bit map主位图。我们直接把扩展位图固定放到128个字段的第一个字段，而主位图每个数据包都有，就强制性放在所有128个字段的前面，并不归入128个字段中去。

    如果某些字段的长度不固定，属于变长怎么办，因为你现在解包是当作数据包每个字段都是固定的，用C语言解包时直接依靠指针取固定长度的一串字符做为一个字段? 比如第2个字段是“帐号”，是不定长的，可能有的银行帐号是19位，有的是17位等。我们定ISO8583规范时可以规定第2个字段是25位，这下足够将19和17的情况都包含进来，但是如果以后出现了30位的怎么办？那我们现在将字段定为100位。以后超过100位怎么办，况且如果你只有19位的帐号，我们定义了100位，那81位的数据不是浪费了网络的带宽。看来预先定义一个我们认为比较大的位数是不太好的。
      
    我们这样，对于第2个字段“帐号”，在字段的开头加上“帐号”的长度。比如帐号是0123456789，一共10位，我们变成100123456789，注意前面多了个10，表示后面的10位为帐号。如果你接触过COM里面的BSTR，应该对这种处理比较熟悉了。接收方收到该字段后，它知道ISO8583规定第2个字段“帐号”是变长的，所以会先取前面的2位出来，获取其值，此时为长度，然后根据该长度值知道应该拷贝该字段后面哪几位数据，才是真正的帐号。如果你觉得长度如果只有两位最多只能表示99位长，不太够，我们也定义可以允许前面3位都为长度的变长字段，这样就有999位长，应该够了吧。在规范里面如果我定义某个字段的属性是“LLVAR”，你注意了，其中的LL表示长度，VAR表示后面的数据，两个LL表示两位长，最大是99，如果是三位就是“LLLVAR”，最大是999。这样看我们定义的ISO8583规范文档时直接根据这几个字母就理解某个变长字段的意思了。

 

### 2、XML格式报文

XML是一种可扩张标志语言，可扩展性指允许用户按照XML规则自己定义标记（tags标签）。

语法规则：

    XML文件有且仅有一个根标记，其他标记必须封装在根标记中，文件的标记必须形成树状结构。
    
    大小写敏感。
    
    标记的属性必须用""或''括起来。

XML细节：

一、 声明

    大多数XML文档以XML声明作为开始，它向解析器提供了关于文档的基本信息。
    
    建议使用XML声明，但它不是必需的。如果有的话，那么它一定是文档的第一行内容。
    
      如：<?xml  version="1.0"  encoding="UTF-8" standalone="no"?>
    
    声明最多可以包含三个名称-值对（许多人称它们为属性，尽管在技术上它们并不是）。
    
      <?xml 问号与xml之间不能有空格。
    
    1) version 是使用的XML 版本:1.0, 1.1
    
    2) encoding 是该文档所使用的字符集。该声明中引用的ISO-8859-1 字符集包括大多数西欧语言用到的所有字符。
    
      默认字符在UTF-8字符集中，这是一个几乎支持世界上所有语言的字符和象形文字的Unicode 标准。
    
    3)standalone（可以是yes 或no）定义了是否孤立处理该文档。
    
      如果XML文档没有引用任何其它文件，则可以指定 standalone="yes"。
    
      如果XML文档引用其它描述该文档可以包含什么的文件(如DTD)，则 standalone="no"。默认值为"no"


二、 标记

    左尖括号“<“和右尖括号“>“之间的文本
    
      1. 在<  >中的称为开始标记；在</  >中的称为结束标记
    
      2. 空标记：不包含元素的标记。空标签必须以“/>”结束。格式： <空标记的名称/> <空标记的名称 属性列表/>
    
    注意：
    
      除空标记外，标签必须成对：有始有终。所有的开始标签和结束标签必须匹配。
    
      在标记符“<“和"标记的名称"之间不能含有空格。在标记符"/>"前面可以有空格或回行。
    
      标签必须嵌套正确。
    
    XML标记必须遵循下面的命名规则:
    
    　1.名字中可以包含字母、数字以及其它字母或文字；还可包含下划线(_)、点(.)、连字符(-)
    
    　2.名字不能以数字开头；可以用字母、文字或者下划线开头。
    
    　3.名字不能以字母xml (或XML 或Xml ..) 开头；
    
    　4.名字中不能包含空格。

三、 元素

    位于开始标记与结束标记间
    
    一份文档有且只有一个根元素。
    
    根元素下的所有元素叫“子元素”。
    
    标签必须嵌套正确。
    
    不包含自子元素的元素叫“叶子”；包含子元素的元素叫“分支”。
    
    如： <eric>…… </eric>

五、 注释

    注释可以出现在文档的任何位置。(但不建议放在声明前面，部分浏览器会报错)
    
    注释以 <!-- 开始，以 -->  结束。
    
    注释内不能包含双连字符（--）；除此之外，注释可以包含任何内容。
    
    注释内的任何标记都被忽略


六、 处理指令

    处理指令是为使用一段特殊代码而设计的标记，简称为PI。
    
    大多数XML 文档都是以XML 声明开始，该声明本身就是特殊的处理指令。
    
    处理指令对应用程序特定的数据进行编码。一条处理指令包含一个目标，后跟数据。用<?和?>定界符将处理指令包起来。
    
    目标确定应用程序，而对应用程序不能识别的目标，其会忽略这些处理指令。


七、 实体

    XML 规范预定义了五个实体。
    
      <   ==== <
    
      >   ==== >
    
      " ==== ”
    
      ' ==== ‘
    
      &  ==== &
    
    自定义实体:在DTD中定义 <!ENTITY 实体标志 "实体内容">
    
      在xml中引用自定义实体，用  &实体标志;  代表实体内容。
    
    另外，无法从键盘输入的字符可以使用字符引用，就是用字符的Unicode代码点来引用该字符。
    
      以"&#x"开始字符引用，以分号结尾，x必须为小写，使用十六进制。如： = 表示等于号。
    
      也可以使用字符引用来引用 <,>,',",&  "

八、 CDATA

    当一段文本中出现很多实体引用和字符引用时，会导致文本数据的读写困难，CDATA段就是为了解决这一问题引入的。
    
    DATA区段开始于 "<![CDATA["  结束于  "]]>"
    
    CDATA内部的所有东西都会被解析器忽略解析，不用检查它的格式。
    
    但是CDATA段中不能嵌套另一个CDATA段。


九、 属性

    属性是标记的属性，可以为标记添加附加信息。
    
    (1)属性的组成
    
       属性是一个名值对，必须由名称和值组成，属性必须在标记的开始标记或空标记中声明，用"="为属性指定一个值。
    
       语法如下：
    
           <标记名称 属性列表/>
    
           <标记名称 属性列表>XXX</标记名称>
    
       例如: <桌子 width="40" height='100'/>
    
    (2)使有属性的原则
    
       属性不体现数据的结构，只是数据的附加信息；
    
       一个信息是作为一个标记的属性或子标记，取决于具体问题，不要因为属性的频繁使用破坏XML的数据结构。
    
       下面是一个结构清晰的XML文件:
    
           <楼房 height="23m" width="12m">
    
               <结构>混凝土</结构>
    
               <类别>商用</类别>
    
           </楼房>
    
      下面是一个结构不清晰的XML文件:
    
          <楼房 height="23m" width="12m" 结构="混凝土" 建筑商="华海集团" 类别="商用"></楼房>

、 名称空间/包

    XML文件允许自定义标记，所以可能出现同名字的标记，为了区分这些标记，就需要使用名称空间。
    
    名称空间的目的是有效的区分相同的标记，其实并不真实存在。
    
    语法： 声明有前缀的名称空间  xmlns:前缀名=名称空间的名字
    
          声明无前缀的名称空间  xmlns=名称空间的名字  (缺省)
    
    注意：当且仅当它们的名字相同时称二个名称空间相同，也就是说，对于有前缀的名称空间，如果二个名称空间的名字相同，即使前缀不相同，也是相同的名称空间，返之同然。前缀只是方便引用而已。




基本术语

    一、序言Prolog：包括XML声明(XML Declaration)和文档类型声明(Document Type Declaration)。
    
    二、良构(well-formed 规范的)：符合W3C定义的XML文档。


验证

    为什么需要验证？
    
    对XML文件施加额外的约束，以便交流。


一、DTD验证

    文档类型定义(Document Type Definition)
    
    DTD定义了XML文档内容的结构，保证XML以一致的格式存储数据。精确的定义词汇表，对XML的内容施加约束。
    
    符合DTD的规范XML文档称为有效的文档。由DTD定义的词汇表以及文档语法，XML解析器可以检查XML文档内容的有效性。
    
    规范的XML文件不一定是有效的；有效的一定是规范的。


1、 DTD声明

    1) DTD声明可以在单独的一个文件中
    
    2) DTD声明可以内嵌在XML文件中
    
    3) DTD声明可以一部分在单独的文件中，另一部分内嵌在XML文件中


2、 引入外部DTD文件

    <!DOCTYPE data SYSTEM "Client.dtd">
    
    Data：根节点名称
    
    Client.dtd：dtd文件路径

3、 DTD四种标记声明

    元素(ELEMENT)、属性(ATTLIST)、实体(ENTITY)、符号(NOTATION)


  1) 元素(ELEMENT) XML元素类型声明

     声明元素： <!ELEMENT elementName (contentModel)>

     元素的内容通过内容模式来描述。

     DTD 内容模式的种类有：

         EMPTY   元素不能包含任何数据，但可以有属性(前提是必须声明其属性)。
         
                 不能有子元素。不能有文本数据（包括空白，换行符）。
         
                 DTD中定义： <!ELEMENT elementName EMPTY>
         
                 XML中：<elementName/>（推荐） 或者：<elementName></elementName>

       (#PCDATA) 规定元素只包含已析的字符数据，而不包含任何类型的子元素的内容类型。

                 DTD中定义： <!ELEMENT student (#PCDATA)>
         
                 XML中合法内容： <student>watching TV</student>

      (Elements) 元素由内容模式部件指定。

                 <!ELEMENT  name  (child particles) >
         
                 内容模式部件可以是下表列出的内容。
         
                    <!ELEMENT name (a,b)>  子元素a、b必须出现，且按照列表的顺序
         
                    <!ELEMENT name (a|b)>  选择；子元素a、b只能出现一个
         
                    <!ELEMENT name (a)  >  子元素a只能且必须出现一次
         
                    <!ELEMENT name (a)+ >  子元素a出现一次或多次
         
                    <!ELEMENT name (a)* >  子元素a出现任意次(包括零次、一次及多次)
         
                    <!ELEMENT name (a)? >  子元素a出现一次或不出现

        Mixed    混合模式：子元素中既可有文本数据又可有下级子元素。

                 <!ELEMENT rn (#PCDATA| an | en)*>“|”和“*”必须写。
         
                 上句表示在 rn 内，字符数据 或 en及an 可以出现任意多次，顺序不限。
         
                 优先写(#PCDATA)  如：(#PCDATA|name)* 正确   (name|#PCDATA)* 错误
         
         ANY     元素可以包含任何类型的数据。子元素(必须在DTD中有定义) 和 文本数据(包括空白)。
         
                 DTD中定义： <!ELEMENT a ANY> <!ELEMENT b ANY>
         
                 XML中合法内容： <a>somngthing</a> 或者 <a/> 或者 <a><b>oo</b></a>


   2) 属性(ATTLIST) 特定元素类型可设置的属性&属性的允许值声明

        <!ATTLIST elementName

        attributeName1 attributeType attributeDefault

        .......

        attributeNameN attributeType attributeDefault>

 .......

        attributeNameN attributeType attributeDefault>
    
     属性类型 (Attribute Type)：
    
        CDATA该属性只能包含字符数据(注意与CDATA段、PCDATA的区别)
    
        NMTOKEN  是CDATA的子集，它的字符只能是字母,数字,句点,破折号,下划线或冒号。
    
        NMTOKENS 类似NMTOKEN，但这个可以包含多个值，每个值之间用空格隔开。
    
        ID       该属性的取值在同一文档内是唯一的。一个元素只能有一个ID类型的属性。
    
        IDREF    类似指针，指向文档中其他地方声明的ID值。如果该属性取值和指向的ID值不匹配，则返回错误。
    
        IDREFS   类似IDREF，但它可以具有由空格分隔开的多个引用。
    
        ENTITY   该属性的值必须对应一个在文档内部声明的但还没有分析过的实体。
    
        ENTITYS  类似ENTITY，但它可以包含由空格分隔开的多个实体。
    
        NOTATION 该属性的值必须引用在文档中其他地方声明的某个注释的名称。
    
        (enumerated) 类似枚举的变量，该属性必须匹配所列的值。各值用“|”分隔开。
    
                 如： (春|夏|秋|冬) 实际内容文档只能从中取一个。
    
     属性特性 (Attribute Default) ：
    
        #REQUIRED   必须有且只能有一个属性。
    
        #IMPLIED    可有可无。
    
        #FIXED      在DTD中定义默认值，XML中可以不指定，指定则必须等于该默认值。
    
        attribute-value 如果不指定则用DTD定义的默认值，指定则用指定的值。

<![CDATA[############ 属性(ATTLIST)的举例 ############## ]]>

例一（#REQUIRED）

    DTD中： <!ELEMENT el (#PCDATA)> <!ATTLIST el at1 NMTOKENS #REQUIRED  at2 CDATA #REQUIRED>
    
    XML中，正确： <el at1 = "10 20" at2="10" >something</el>
    
    XML中，错误： <el at="10">something</el>  (没有写另一个#REQUIRED的属性 at2 )


例二(#IMPLIED，#FIXED)

    DTD中： <!ELEMENT el (#PCDATA)> <!ATTLIST el at CDATA #FIXED "10"  at2 CDATA #IMPLIED >
    
    XML中，正确： <el at2="20" >something</el> （at有默认值"10"，at2 可写可不写)
    
    XML中，错误： <el at="11" >something</el>（at要么不写，要写只能写成跟默认值相同的）


例三(attribute-value)

    DTD中：<!ELEMENT el (#PCDATA)> <!ATTLIST el at CDATA "10" at2 CDATA "20" >
    
    XML中，正确： <el at="11" >something</el>


例四(enumerated + attribute-value)

    DTD中：<!ELEMENT el (#PCDATA)> <!ATTLIST el at (10|20|30) "10">
    
    XML中，正确： <el at="20">something</el>  (at要么不写，默认值 10；要么在(10|20|30)中选一个写)

<![CDATA[############ 属性(ATTLIST)举例 完毕 ############## ]]>


  3) 实体(ENTITY)   可重用的内容声明

     在DTD中定义 <!ENTITY 实体标志 "实体内容">

     在xml中引用自定义的实体，用  &实体标志;  代表实体内容。

      4) 符号(NOTATION) 不要解析的外部内容的格式声明。



3、 内部实体：在xml文件里面写(少用)

    外部实体：另外在xml同一文件夹下建立一个dtd文件(提倡)

<!--**************** 内外部的实体举例 ***************** -->

外部的：

      <?xml  version="1.0"  encoding="UTF-8" standalone="no"?>
    
      <!DOCTYPE root SYSTEM "goodsInfo.dtd"><!--用这句引用外部dtd-->
    
      <root><goodsInfo>
    
          <goodsName>goodsName</goodsName>
    
          <goodsPrice>goodsPrice</goodsPrice>
    
      </goodsInfo></root>

 以下是名为"goodsInfo.dtd"文件
      <!ELEMENT root   (goodsInfo)>
      <!ELEMENT goodsInfo  (goodsName,goodsPrice)>
      <!ELEMENT goodsName  (#PCDATA)>
      <!ELEMENT goodsPrice (#PCDATA)>

内部的：
      <?xml  version="1.0"?>
      <!DOCTYPE root [
          <!ELEMENT root(student)>
          <!ELEMENT student (#PCDATA)>
          <!ENTITY CCTV  "中央电视台">
      ]>  <!--把DTD文件写在体内-->
      <root><student>
          student watch &CCTV;<!--使用自定义实体 CCTV-->
      </student></root>
<!--***************** 内外部的实体举例 完毕 ********************** -->


XML处理模式
一、 DOM 文档对象模式
    1.DOM特点：
      以树型结构访问XML文档。 一棵DOM树包含全部元素节点和文本节点。可以前后遍历树中的每一个节点。
      整个文档树在内存中，便于操作；支持删除、修改、重新排列等多种功能。
      将整个文档调入内存（包括无用的节点），浪费时间和空间。
      一旦解析了文档还需多次访问这些数据；硬件资源充足（内存、CPU）情况下使用。
    2.DOM树与节点
      XML文档被解析成树型结构。
      树由节点组成。共有12种不同的节点。
      节点可以包含其他节点（依赖于节点的类型）。
      父节点包含子节点。叶子节点没有子节点。
    3.节点类型
      Document node   包含：一个根Element节点。一个或多个处理指令节点。
      Document Fragment node
      Element node包含：其他Element节点。若干个Text节点。若干个Attribute节点。
      Attribute node  包含：一个Text节点。
Text node
      Comment node
      Processing instruction node
      Document type node
      Entity node
      Entity reference node
      CDATA section node
      Notation node

### 3、HTTP协议报文基本格式

HTTP协议（Hypertext　Transfer　Protocol――超文本传输协议），浏览器端（客户端）向WEB服务器端访问页面的过程和HTTP协议报文的格式。
注：Ascii码：回车=0x0D('\r'), 换行=0x0A('\n').

    基于HTTP协议的客户机访问包括4个过程，分别是建立TCP套接字连接、发送HTTP请求报文、接收HTTP应答报文和关闭TCP套接字连接，HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，各个字段的长度是不确定的。HTTP有两类报文：请求报文和响应报文。
建立连接：
连接的建立是通过申请套接字(Socket)实现的。客户打开一个套接字并把它约束在一个端口上，如果成功，就相当于建立了一个虚拟文件。以后就可以在该虚拟文件上写数据并通过网络向外传送。通俗地说就是TCP的三次握手
发送请求：
首先，这个消息是用普通的ASCII文本书写的。这个消息共有多行(每行以一个回车符和一个换行符结束)，最后一行后面还有额外的一个回车符和换行符。当然，一个请求消息也可以仅仅只有一行。请求的报文中包含了各种信息，包括客户端想要访问的URL，HTTP的版本，支持的浏览的字体等内容。详细分析见2.2.1请求报文字段
发送响应 ：           
服务器在处理完客户的请求之后，要向客户机发送响应消息。
 这个响应消息分为3部分：1个起始的状态行(status line)，6个头部行（不固定）、1个包含所请求对象本身的附属体。状态行有3个字段:协议版本字段、状态码字段、原因短语字段。
关闭连接：
 客户和服务器双方都可以通过关闭套接字来结束TCP/IP对话。通俗地说就是TCP的4次握手断开。常见的应用环境就是这样，实际生活中可能就是多了一个NAT转换，其实过程都是一样的。

1. 创建TCP套接字连接
    客户端与WEB服务器创建TCP套接字连接，其中WEB端服务器的地址可以通过域名解析确定，WEB端的套接字侦听端口一般是80。
2. 发送HTTP请求报文
    客户端向WEB服务端发送请求报文，HTTP协议的请求报文格式为：
    请求消息 = 请求行（实体头信息）CRLF[实体内容]
    请求行 = 方法　URL　HTTP版本号　CRLF
    方法 = GET|HEAD|POST|扩展方法
    URL = 协议名称 ＋ 宿主名 ＋ 目录与文件名

    其中"CRLF"表示回车换行。
    "请求行"中的"方法"描述了对指定资源执行的动作，常用的方法"GET"、"HEAD"和"POST"等3种，它们的含义如表15-8所示：
    表15-8 HTTP请求方法
    取值
    描述
    GET
    从WEB服务器中获取对象，不同类型的对
    象将获取不同的信息，比如：
    · 文件类型对象，获取该文件的内容。
    · 程序类型对象，获取该程序执行的结果。
    · 数据库查询类型对象，获取该查询的结果。
    HEAD
    要求服务器查找对象的元信息。
    POST
    从客户端向WEB服务器发送数据。

    "实体头信息"中记载了报文的属性，利用这些信息可以实现客户端与WEB服务器之间的请求或应答，它包括报文的数据类型、压缩方法、语言、长度、压缩方法、最后一次修改时间、数据有效期等信息。
    实体内容是报文传送的附加信息，一般供POST请求填写。

GET请求报文例子
    一个URL为" http://www.zhiliaowang.com/toupiaoceshi.asp?name =朱云翔"的GET请求报文例子如下：
GET http://www.zhiliaowang.com/toupiaoceshi.asp?name=朱云翔 HTTP/1.1
Accept: */*
Accept-Language: zh-cn
Accept-Encoding: gzip, deflate
User-Agent: Mozilla/4.0 (compatible; MSIE 6.0; 
Windows NT 5.1; SV1; .NET CLR 2.0.50727)
Host: www.zhiliaowang.com
Connection: Keep-Alive
    其中"/toupiaoceshi.asp?name=朱云翔"是URL信息，语句"ACCEPT：*/*"及其后的语句是"实体头信息"。
    注意：在语句"Connection：Keep-Alive"下的空行是必须的。

POST请求报文例子
    下面是HTTP协议中关于POST请求报文例子，节自《中国联合通信公司短消息网关系统接口协议(SGIP)》V1.2版：
POST /sp.cgi HTTP/1.0     /* 请求行，服务程序为sp.cgi */
Host: www.spserver.com     /* 以下为实体头信息 */
Authorization: Basic <Base64 串>
Content-Length: <Content-Length>
<CommandId>=<4>       /* 以下为POST请求的实体信息 */
<SequenceNumber>=<205502327125025327> /* 实体部分输送报文 */
<UserNumber>=<8613001125453>
<SPNumber>=<168>
<MessageContent>=<ABCD 1234>

    一般情况下，采用POST报文传送信息的数据存储在"实体"部分中。

请求报文附注：
    HTTP请求包括三部分：请求行(Request Line)，头部(Headers)和数据体(Body)。其中，请求行由请求方法(method)，请求网址Request-URI和协议 (Protocol)构成，而请求头包括多个属性，数据体则可以被认为是附加在请求之后的文本或二进制文件。

    下面这个例子显示了一个HTTP请求的Header内容，这些数据是真正以网络HTTP协议从IE浏览器传递到Apache服务器上的。
GET /qingdao.html HTTP/1.1
Accept:text/html, */*
Accept-Language:zh-cn
Accept-Encoding:gzip,deflate
User-Agent:Mozilla/4.0(compatible;MSIE 5.01;Windows NT 5.0;DigExt)
Host:  www.6book.net
Referer:  http://www.6book.net/beijing.html
Connection:Keep-Alive

    这段程序使用了6个Header，还有一些Header没有出现。我们参考这个例子具体解释HTTP请求格式。
1.HTTP请求行：请求行格式为Method Request-URI Protocol。在上面这个例子里，"GET / HTTP/1.1"是请求行。
2.Accept:指浏览器或其他客户可以接爱的MIME文件格式。可以根据它判断并返回适当的文件格式。
3.Accept-Charset：指出浏览器可以接受的字符编码。英文浏览器的默认值是ISO-8859-1.
4.Accept-Language：指出浏览器可以接受的语言种类，如en或en-us，指英语。
5.Accept-Encoding：指出浏览器可以接受的编码方式。编码方式不同于文件格式，它是为了压缩文件并加速文件传递速度。浏览器在接收到Web响应之后先解码，然后再检查文件格式。
6.Authorization：当使用密码机制时用来标识浏览器。
7.Cache-Control：设置关于请求被代理服务器存储的相关选项。一般用不到。
8.Connection：用来告诉服务器是否可以维持固定的HTTP连接。HTTP/1.1使用Keep-Alive为默认值，这样，当浏览器需要多个文件时(比如一个HTML文件和相关的图形文件)，不需要每次都建立连接。
9.Content-Type：用来表名request的内容类型。可以用HttpServletRequest的getContentType()方法取得。
10.Cookie：浏览器用这个属性向服务器发送Cookie。Cookie是在浏览器中寄存的小型数据体，它可以记载和服务器相关的用户信息，也可以用来实现会话功能。
11.Expect：表时客户预期的响应状态。
12.From：给出客户端HTTP请求负责人的email地址。
13.Host：对应网址URL中的Web名称和端口号。
14.If-Match：供PUT方法使用。
15.If-Modified-Since：客户使用这个属性表明它只需要在指定日期之后更改过的网页。因为浏览器可以使用其存储的文件而不必从服务器请求，这样节省了Web资源。由于Servlet是动态生成的网页，一般不需要使用这个属性。
16.If-None-Match：和If-Match相反的操作，供PUT方法使用。
17.If-Unmodified-Since：和If-Match-Since相反。
18.Pragma：这个属性只有一种值，即Pragma：no-cache,表明如果servlet充当代理服务器，即使其有已经存储的网页，也要将请求传递给目的服务器。
19.Proxy-Authorization：代理服务器使用这个属性，一般用不到。
20.Range：如果客户有部分网页，这个属性可以请求剩余部分。
21.Referer：表明产生请求的网页URL。
比如从网页/beijing.html中点击一个链接到网页/qingdao.html,在向服务器发送的GET /beijing.html中的请求中，Referer是 http://www.6book.net/qingdao.html  。这个属性可以用来跟踪Web请求是从什么网站来的。
22.Upgrage：客户通过这个属性设定可以使用与HTTP/1.1不同的协议。
23.User-Agent：是客户浏览器名称。
24.Via：用来记录Web请求经过的代理服务器或Web通道。
25.Warning：用来由客户声明传递或存储(cache)错误。


3. 接收HTTP应答报文
    WEB服务器处理客户请求，并向客户机发送应答报文，HTTP协议的应答报文格式为：
    应答报文 = 状态行（实体头信息）CRLF [实体内容]
    状态行   = HTTP版本号　状态码　原因叙述
    状态码描述了WEB服务器执行客户机请求的状态信息，其取值含义如表15-8所示：
    表15-8 HTTP应答响应码含义
    取值
    描述
    1××
    保留。
    2××
    成功接收，比如“200”表示处理成功。
    3××
    客户需进一步细化请求。
    4××
    客户错误，比如“404”表示访问的
    指定资源不存在。
    5××
    服务器错误。

GET应答报文例子
    一个请求URL为" http://www.zhiliaowang.com/toupiaoceshi.asp?name =朱云翔"的应答报文例子如下：
HTTP/1.1 200 OK
Connection: keep-alive
Date: Thu, 26 Jul 2007 14:00:02 GMT
Server: Microsoft-IIS/6.0
X-Powered-By: ASP.NET
Content-Length: 190
Content-Type: text/html
Set-Cookie: ASPSESSIONIDSAATTCSQ=JOPPKDCAMHHBEOICJPGPBJOB; path=/
Cache-control: private
<html>
<head>
<title>精通Unix下C语言编程</title>
</head>
<body>
<b>精通Unix下C语言编程与项目实战<br></b>
<b>投票测试<br></b>
感谢你为选手
朱云翔
投票!
</body>
</html>
    语句"HTTP/1.1 200 OK"中，"200"是响应码，"OK"是原因描述。
POST应答报文例子
    下面是HTTP协议中关于POST应答报文例子，节自《中国联合通信公司短消息网关系统接口协议(SGIP)》V1.2版：
HTTP/1.0 200 OK       /* 状态行，应答成功 */
Date: Tue, 13 Mar 2001 02:45:12 GMT /* 以下为实体头信息 */
Server: Apache/1.3.12 (Unix)
Content-Type: text/html
Connection: close
<CommandId>=<80000004>     /* 以下为POST应答的实体信息 */
<SequenceNumber>=<205502327125025327>
<UserNumber>=<8613001125453>
<SPNumber>=<168>
<MessageContent>=< EFGH 5678> <Result>=<0>
    一般情况下，POST应答报文的"实体"部分存储实际传输的信息。

4. 关闭TCP套接字连接
     客户机与服务器双方关闭套接字连接，结束TCP/IP对话。

## 四、HTTP协议报文的组成部分

HTTP 报文是简单的格式化文本。

所有的 HTTP 报文都可以分为两类：请求报文和响应报文。请求报文会向 Web 服务器请求 一个动作。响应报文会将请求的结果返回给客户端。请求报文和响应报文的基本报文结构相 同。

HTTP报文是面向文本的，报文中的每一个字段都是一些ASCII码串，每个字段的长度是不确定的。HTTP报文传过来的都是一堆的0x ASCII码，例如" 41 63 63 65 70 74"这段十六进制ASCII码串对应的是“accept” 单词。

这些十六进制的数字经过浏览器或者专用工具比如wireshark或fiddler的翻译，可以得到HTTP的报文结构。

HTTP有两种报文：请求报文和响应报文。

### 请求报文
以下是通过抓包工具fiddler抓出来的一段HTTP请求报文

```http
GET http://jsuacm.cn/ HTTP/1.1 （请求方法）（URL）(HTTP协议版本)
Host: jsuacm.cn
Connection: keep-alive
Upgrade-Insecure-Requests: 1
User-Agent: Mozilla/5.0 (Windows NT 10.0; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/70.0.3538.25 Safari/537.36 Core/1.70.3877.400 QQBrowser/10.8.4506.400
Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8
Accept-Encoding: gzip, deflate
Accept-Language: zh-CN,zh;q=0.9
这一行空着表示请求头部结束
//”请求数据”(GET方式的请求一般不包含)
```

可见HTTP的请求报文由四部分组成：请求行(request line)、请求头部(header)、空行和请求数据(request data)

![在这里插入图片描述](https://img-blog.csdnimg.cn/28f0146f4568480abf9afe951dbfddc9.png)

![img](https://img-blog.csdnimg.cn/img_convert/7cdfc0acd3f9a3368c7b92c7c55f0f42.png)

#### 请求行（就是常见的网址）
请求行由请求方法字段、URL字段和HTTP协议版本字段3个字段组成，它们用空格分隔。例如：GET http://jsuacm.cn/template/jsu/css/modifypage-1.css HTTP/1.1

##### 1，请求方法
HTTP协议的请求方法有GET、POST、HEAD、PUT、DELETE、OPTIONS、TRACE、CONNECT。GET和POST是最常用的请求方法。

GET:最常见的一种请求方式，当客户端要从服务器中读取文档时，当点击网页上的链接或者通过在浏览器的地址栏输入网址来浏览网页的，使用的都是GET方式。GET方法要求服务器将URL定位的资源放在响应报文的数据部分，回送给客户端。使用GET方法时，请求参数和对应的值附加在URL后面，利用一个问号（“?”）代表URL的结尾与请求参数的开始，传递参数长度受限制。
GET方式的请求一般不包含”请求数据”部分，请求数据以地址的形式表现在请求行。显然，这种方式不适合传送私密数据。另外，由于不同的浏览器对地址的字符限制也有所不同，一般最多只能识别1024个字符，所以如果需要传送大量数据的时候，也不适合使用GET方式。

POST:和get一样很常见，对于上面提到的不适合使用GET方式的情况，可以考虑使用POST方式，因为使用POST方法可以允许客户端给服务器提供信息较多。POST方法将请求参数封装在HTTP请求数据中，以名称/值的形式出现，可以传输大量数据，这样POST方式对传送的数据大小没有限制，而且也不会显示在URL中。

HEAD： 本质和get一样，只不过服务端接受到HEAD请求后只返回响应头，而不会发送响应内容。当我们只需要查看某个页面的状态的时候，使用HEAD是非常高效的，因为在传输的过程中省去了页面内容。

其他的请求方法并没有那么常见:
PUT:和post类似，html表单不支持，发送资源与服务器，并存储在服务器指定位置，可用于替换资源，要求客户端事先知道该位置。

DELETE：请求服务器删除某资源。和put都具有破坏性，可能被防火墙拦截。如果是https协议，则无需担心。

CONNECT：HTTP/1.1协议中预留给能够将连接改为管道方式的代理服务器。就是把服务器作为跳板，去访问其他网页然后把数据返回回来，连接成功后，就可以正常的get、post了。

OPTIONS：获取http服务器支持的http请求方法，允许客户端查看服务器的性能，比如ajax跨域时的预检等。

TRACE：回显服务器收到的请求，主要用于测试或诊断。一般禁用，防止被恶意攻击或盗取信息。

##### 2，URL
URL：统一资源定位符，是一种资源位置的抽象唯一识别方法。
组成：<协议>://<主机>:<端口>/<路径>
端口和路径有事可以省略（HTTP默认端口号是80）

![在这里插入图片描述](https://img-blog.csdnimg.cn/97ab2d33fa04456989bca20d68587771.png)

##### 3，HTTP协议版本

协议版本的格式为：HTTP/主版本号.次版本号，常用的有HTTP/1.0和HTTP/1.1，现在最常用的是1.1

###### HTTP 1.0和HTTP 1.1的主要区别是什么?

长连接 : 在HTTP/1.0中，**默认使用的是短连接，也就是说每次请求都要重新建立一次连接**。HTTP是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个**长连接来发多个请求。HTTP1.1起，默认使用长连接 ,默认开启Connection： keep-alive**。 HTTP/1.1的持续连接有非流水线方式和流水线方式 。**流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。**

带宽优化及网络连接的使用 : HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

Host域：在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。HTTP1.0是没有host域的，HTTP1.1才支持这个参数。

错误状态响应码 : 在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

缓存处理 : 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

###### HTTP2.0的优化

新的二进制格式：HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。

多路复用：在同一个TCP连接中，同一时刻可以发送多个请求和响应,下一次的请求不需要等待上一个响应来之后再发送。但响应的顺序是不变的，FIFO（先进先出）。2.0之前是同一个连接只能用一次， 如果开启了keep-alive，虽然可以用多次，但是同一时刻只能有一个HTTP请求。

HTTP2.0的多路复用主要是指：因为http2.0的传输是基于二进制帧的。每一个TCP连接中承载了多个双向流通的流，每一个流都有一个独一无二的标识和优先级，而流就是由二进制帧组成的。二进制帧的头部信息会标识自己属于哪一个流，所以这些帧是可以交错传输，然后在接收端通过帧头的信息组装成完整的数据。这样就解决了线头阻塞的问题，同时也提高了网络速度的利用率。

header压缩，HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用HPACK算法对header的数据进行压缩，避免了重复header的传输，又减小了需要传输数据的大小，基本原理是客户端和服务端分别缓存一份索引表，如果头部存在于索引表，则用对应的索引值；否则进行霍夫曼编码，并加入索引表。参考

**索引表**

　　HPACK中有2个索引表，分别是静态索引表和动态索引表。静态索引表是RFC 预先定义好的，只有固定的几十个值，如下图所示：
![这里写图片描述](https://img-blog.csdn.net/20180607111231669?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3lhbmdndW9zYg==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70)

动态表是一个由先进先出的队列维护的有空间限制的表。每个动态表只针对一个连接，每个连接的压缩解压缩的上下文有且仅有一个动态表。当一个头部没有出现过的时候，会被插入动态表中，下次同名的值就可能会在表中查到到索引并替换掉头部。

参考：

https://www.jianshu.com/p/f44b930cfcac；
https://imququ.com/post/header-compression-in-http2.html；

服务器推送， 当我们对支持HTTP2.0的web server请求数据的时候，服务器会顺便把一些客户端需要的资源一起推送到客户端，免得客户端再次创建连接发送请求到服务器端获取。这种方式非常合适加载静态资源。服务器端推送的这些资源其实存在客户端的某处地方，客户端直接从本地加载这些资源就可以了，不用走网络，速度自然是快很多的。

#### 请求头部

请求头部为请求报文添加了一些附加信息，由“名/值”对组成，每行一对，名和值之间使用冒号分隔。请求头部通知服务器有关于客户端请求的信息。比较常见的有：

![在这里插入图片描述](https://img-blog.csdnimg.cn/70810659bd9e4ffd831dc14464e997a9.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 空行
请求头部的最后会有一个空行，表示请求头部结束，接下来为请求数据。

#### 请求数据

请求数据不在GET方法中使用，而在POST方法中使用。POST方法适用于需要客户填写表单的场合。与请求数据相关的最长使用的请求头部是Cntent-Type和Content-Length

### 响应报文
以下是通过抓包工具fiddler抓出来的一段HTTP响应报文

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">
	<link rel="icon" href="../../favicon.ico">

```html
HTTP/1.1 200 OK
Server: nginx/1.18.0 (Ubuntu)
Date: Wed, 20 Oct 2021 06:46:15 GMT
Content-Type: text/html; charset=UTF-8
Connection: keep-alive
Expires: Thu, 19 Nov 1981 08:52:00 GMT
Cache-Control: no-store, no-cache, must-revalidate
Pragma: no-cache
Content-Length: 737265

<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge">
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="">
	<meta name="author" content="">
	<link rel="icon" href="../../favicon.ico">

	<title>
		吉首大学	
		</title>

```


HTTP响应报文由状态行（status line）、响应头部（headers）、空行（blank line）和响应数据（也叫响应体或响应正文）（response body）4个部分组成。

![img](https://img-blog.csdn.net/20150126110634828?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvY2hlbmhhbnpodW4=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

![img](https://img-blog.csdnimg.cn/img_convert/8ace1fd2c4c5cb044f1b43dd6379a1be.png)

#### 状态行

状态行由3部分组成，分别为：协议版本、状态码、状态码描述。其中协议版本与请求报文一致，状态码描述是对状态码的简单描述。

HTTP状态码

![在这里插入图片描述](https://img-blog.csdnimg.cn/08f780f945204228b2d30d141de06e38.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 响应头部
常见响应头部及描述如下：

![在这里插入图片描述](https://img-blog.csdnimg.cn/e0fdcf851081478f8d21d383829528d1.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAWXNtaW5nODg=,size_20,color_FFFFFF,t_70,g_se,x_16)

#### 空行
响应头部的最后会有一个空行，表示响应头部结束，接下来为响应数据。与请求报文一致。

#### 响应体
用于存放需要返回给客户端的数据信息。fiddler抓出来的一段HTTP响应数据是一段HTML。